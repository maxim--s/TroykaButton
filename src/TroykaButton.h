/****************************************************************************/
//  Function:       Header file for TroykaButton
//  Arduino IDE:    Arduino-1.8.13
//  Author:         Igor Dementiev and Maxim Shatskih
//  Date:           Aug 14,2020
//  Version:        v2.0
//  by www.amperka.ru and contributors
/****************************************************************************/

#ifndef _TROYKA_BUTTON_H_
#define _TROYKA_BUTTON_H_

#if defined(ARDUINO) && (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

//
//                            Arduino и HARD REALTIME
//
// - в связи с тем, что как аппаратура, так и core libraries Arduino очень просты,
//    контроллер вполне может дать hard realtime
// - иначе говоря, худшее время отклика кода на аппаратные события в самом чипе и периферии
//    может быть очень и очень малым
// - но! для этого необходима определенная манера программирования
// - проблема возникает, например, при использовании delay(),
//    ибо во время delay() аппаратура (если она работает не по прерываниям)
//    не опрашивается,
//    а стандартный обработчик прерывания (у Serial, например) тривиален и не может дать
//    реализацию сложного протокола вопрос-ответ, обработки событий и др
// - проблему усугубляет то, что delay() может быть где-то глубоко внутри по стеку вызовов,
//    зависимостей библиотек и др
// - сам delay() реализован как опрос millis() в цикле,
//    при этом на каждом обороте зовется yield(),
//    который на чипах AVR (ATmegaXxx - обычные Arduino) не реализован
//     он реализован только на старших моделях Arduino типа MKRxxxx,
//     в которых используется другой чип, мощнее AVR,
//     и в которых есть библиотека Scheduler
//     реализация Scheduler на AVR вряд ли возможна,
//      ибо каждому потоку нужен стек,
//      а динамически уместить стеки потоков в 2KB RAM вряд ли возможно
// - потому имеет смысл принять следующие законы программирования:
//    * никогда не пользоваться delay(), вообще забыть о наличии этой функции
//    * вместо этого в каждом классе завести метод loop() (в данном классе - read()),
//       который нужно звать на каждом обороте основного loop()
//       и реализовать там логику state machine,
//       которая для привязки ко времени будет звать millis()
//

//
//  ВНИМАНИЕ:
//
// - если кнопка была аппаратно нажата в момент выполнения конструктора или reinit(),
//     например, если Arduino включили с нажатой кнопкой,
//    то произойдет то же самое, как если бы кнопка была отпущена,
//    а нажали ее сразу после возврата из конструктора или reinit()
// - эта логика необходима для реализации подавления дребезга,
//    с учетом того, что в конструкторе, как правило, невозможно прочесть состояние пина
//

//
//              Логика подавления дребезга
//
// - ожидается, пока электрическое состояние пина не менялось в течение DEBOUNCE_TIME
// - после этого состояние пина считается окончательным
//

// время подавления дребезга в ms
// для кнопки AMP-B077-B 50ms - слишком много, легко кликнуть кнопку так,
//  что нажатое состояние будет держаться меньше 50ms
#define DEBOUNCE_TIME   15

//
// поскольку компилятор и toolchain avr-gcc (на котором основана Arduino IDE)
//  очень активно все инлайнит и использует link-time кодогенерацию для этого
//  (как Microsoft C/C++ для Win64),
//  мы объявим здесь инлайны в стандартной манере C++ без форсирования
// никогда не стоит забывать, что в экосистеме Arduino
//  мы имеем могучий и "взрослый" компилятор,
//  хотя target и 8битная и имеет зачастую около 2К памяти
//

class TroykaButton
{
public: // API
  // pin - номер пина
  // timeHold - время (в ms) непрерывного удержания кнопки,
  //  после которого нажатие понимается как долгое удержание
  // pullUP - должен быть true, если пин оттянут резистором к питанию,
  //  и false - если к земле
  TroykaButton(uint8_t pin, uint32_t timeHold = 2000, bool pullUP = true);
  // полный сброс объекта, после которого он становится таким же,
  //  как сразу после конструктора + begin() + единственного read()
  // повторно звать begin() - не требуется
  // новый таймаут от setTimeHold() НЕ сбрасывается к старому
  // может быть полезен в случае, если на кнопку временно повесили прерывание,
  //  а затем вернулись к использованию этого класса
  void reinit() {
    _resetObject();
    begin(); // мало ли что успели понаделать с этим пином
    read(); // для ре-инициализации подавления дребезга
  }
  // изменяет заданное в конструкторе время (в ms) непрерывного удержания кнопки,
  //  после которого нажатие понимается как долгое удержание
  // может быть полезен в случае, если используется логика нажатий на кнопку
  //  азбукой Морзе (или как-то вроде), как в некоторых брелках автосигнализаций
  void setTimeHold(uint32_t newTimeHold) { _timeHold = newTimeHold; }
  // инициализация кнопки (для вызова в setup())
  void begin() { pinMode(_pin, INPUT); }
  // считывание данных с кнопки
  // обновляет внутреннее состояние объекта на основании состояния пина
  // для вызова в loop() каждый раз
  void read();
  // определение клика кнопки
  // возвращает true тогда и только тогда, когда:
  //  1) ранее отпущенная кнопка была нажата
  //  И
  //  2) только при первом вызове после того, как выполнилось условие 1)
  // возвращает false во всех остальных случаях
  // можно сказать, что этот метод работает "по фронту"
  bool justPressed() { return _justXxxInner(stPressed); }
  // определение отжатия кнопки
  // то же, что и justPressed(), но условие 1) выглядит как:
  //  "ранее нажатая кнопка была отпущена"
  bool justReleased() { return _justXxxInner(stReleased); }
  // определение удержания кнопки
  // то же, что и justPressed(), но условие 1) выглядит как:
  //  "нажатая кнопка удерживалась нажатой в течение >= timeHold миллисекунд"
  bool justHeld() { return _justXxxInner(stLongHold); }
  // true, если кнопка нажата "здесь и сейчас", иначе false
  bool isPressed() const { return _state == stPressed || _state == stLongHold; }
  // true, если кнопка отпущена "здесь и сейчас", иначе false
  bool isReleased() const { return _state == stReleased; }
  // true, если кнопка нажата "здесь и сейчас",
  //  и удерживалась нажатой в течение >= timeHold миллисекунд, иначе false
  bool isHold() const { return _state == stLongHold; }
  // определение короткого клика, если сработал метод isHold() клик не сработает.
  // то же, что и justReleased() (именно так! для совместимости со старым кодом)
  //  с той лишь разницей, что justReleased() вернет true
  //  и в случае долгого (timeHold) удержания кнопки,
  //  а этот метод в таком случае вернет false
  // isClick() не до конца совместим с justReleased(),
  //   а именно, если isClick() уже вернул true, то justReleased() вернет false
  //   а если justReleased() уже вернул true, то isClick() вернет false
  // возможно совместное использование isClick() и justReleased() в виде:
  //   - первым в loop() должен зваться isClick()
  //   - justReleased() должен зваться, только если isClick() вернул false
  //   - тогда, если justReleased() вернет true,
  //       это будет означать "отпускание после долгого удержания"
  //   - результат isClick() при этом можно проигнорировать
  bool isClick();
private: // данные инициализации
  // номер пина
  const uint8_t _pin;
  // время длительного зажатия кнопки
  uint32_t _timeHold;
  // выбор подтяжки
  const bool _pullUP;
private: // данные состояния
  enum _State {
    stReleased,
    stPressed,
    stLongHold, // во всех современных компиляторах можно ставить здесь запятую
  };
  // запомненное электрическое состояние пина (с поправкой на _pullUP)
  bool _pinState;
  // millis(), когла было прочитано и сохранено _pinState
  unsigned long _miPinState;
  // true, если течет временной интервал подавления дребезга, иначе false
  bool _isDebounceTimeoutActive;
  // текущее "софтовое" состояние кнопки
  _State _state;
  // предыдущее состояние кнопки (используется только в isClick())
  _State _prevState;
  // true, если _state изменилось, и после этого еще не был вызван
  //  один из justXxx() методов или isClick()
  bool _isStateDirty;
  // millis() последнего обновления _state
  // нужно для таймаута удержания, мы не можем использовать _miPinState
  //  для него, ибо тогда ложное кратковременное дребезжащее размыкание нажатой кнопки
  //  сбросит логику timeHold
  unsigned long _miState;
private: // внутренности
  // внутренний движок под конструктором и reinit()
  // инициализирует все поля состояния
  void _resetObject();
  // единый, для экономии места под код, внутренний движок под всеми justXxx()
  bool _justXxxInner(_State stateToTest);
  // читает электрическое состояние пина (с поправкой на _pullUP)
  bool _readPinState() const {
    // != для типа bool есть xor
    return (digitalRead(_pin) == HIGH) != _pullUP;
  }
  // запоминает состояние пина правильным образом
  void _updatePinState(bool newPinState) {
    _pinState = newPinState;
    _miPinState = millis();
  }
  // oбновляет _state правильным образом
  void _updateState(_State newState) {
    _prevState = _state;
    _state = newState;
    _isStateDirty = true;
    _miState = millis();
  }
};

#endif // _TROYKA_BUTTON_H_
